""" Implements A* search with a Fibonacci heap for fast decrease-key
operations.

The AStar or AStarHashable class must be subclassed to apply A* to a
specific problem domain.

Originally written by: Mark Wilson (mw54) 9/3/2010, based on code by
Ikhyun Park

Last updated: 1/17/2019 (Kris Hauser)
  - Cleaned up docstrings to be Google-style.
"""

from __future__ import print_function
import weakref
import sys


class AStarNode:
    """A node in the A* search tree.  Stores heuristic value (h),
    cost-from-start value (g), overall cost value (f=h+g), a node id, an
    associated search state, a parent node, an optional piece of data
    associated with the edge, and a list of children. 

    Users' interaction with this type should be fairly limited, the only
    necessary direct uses being:
    
    - Storing a reference to an AStarNode associated with a given search state,
      for tracking visited states (see documentation on AStar for overriding
      its visit(), visited_state_node(), and clear_visited() methods).
    - Inspecting nodes along the final path from start to goal, as returned by
      AStar's result_path() method.

    Attributes:
        f (float): cost-through-node estimate h+g
        g (float): cost-to-come from start
        h (float): heuristic estimate of cost-to-go
        nid (int): an id used in AStar
        state: user-defined data representing state
        parent (weak reference to AStarNode): the parent node
        parentedge: user-defined data representing action to arrive here from
            parent
        children (list of AStarNode): children of this node in the search tree.
    """
    
    def __init__(self, f=0, h=0, g=0, nid=0, state=None,
             parent=None, parentedge=None,
             children=None):
        self.f = f
        self.h = h
        self.g = g
        self.nid = nid
        self.state = state
        # Since parent holds a ref to children, we want a weak reference
        # to the parent to ensure garbage collection despite circular refs
        self.parent = weakref.proxy(parent) if parent else None
        self.parentedge = parentedge
        # Can't do children=[] in parameter list as all nodes wind up with
        # the same list
        self.children = children if children else []
        



class AStar:
    """An A* search problem instance.  A* search proceeds over states in the
    search space and stores visited states in tree nodes represented as
    AStarNode instances.  State types are defined by the user, but the user
    must be able to compare newly-generated states to old states to avoid
    revisiting states. 

    This class is intended to be subclassed by the user for
    a specific search space.  The following methods should be overridden:
    
    - is_goal()
    - successors()
    - clear_visited()
    - visit()
    - visited_state_node()
    - heuristic()

    Note that if you use the AStarHashable class, you only need implement the
    is_goal(), successors(), and heuristic() functions.
    
    NB:  The AStar.__init__() constructor should be called by the
    subclass.  If a start state is provided, be prepared for it
    to call clear_visited() and visit()!  This means that whatever
    structure you need for tracking visited states  should already be
    in place or should be initialized if necessary by those methods.
    
    After initialization, you can call search_step() to perform one step of the
    A* search, or search() to do a whole search to completion or failure.  Either
    will return True if a goal has been reached and False otherwise.
    
    After a successful search, you may inspect the data member "goal" to see
    the goal state and call result_path() for a list of AStarNode objects
    from start to goal.  You may also call num_nodes() for the total number
    of nodes in the search tree.

    Attributes:
        testGoalOnGeneration (bool, default False): see initializer
            documentation.
        boundGoalCost (bool, default False): if set to True, a search can be
            pruned early if it is known that the optimal cost is greater than
            the lower bound bestAvailableGoalCost.
        bestAvailableGoalCost (float): if boundGoalCost = True, the threshold
            for terminating search early.  This is passed as the maxCost
            parameter to successors.
    """
    
    def __init__(self, state=None, testGoalOnGeneration=False):
        """Initializes a search with the given start state (a user-defined
        type). 

        If testGoalOnGeneration is True, then goal conditions will be
        tested on new states as soon as they are generated by the successors()
        method.  This may end the search more quickly but may also give
        sub-optimal results.
        """
        
        self.testGoalOnGeneration = testGoalOnGeneration
        self.boundGoalCost = False
        self.bestAvailableGoalCost = float('inf')
        if state!=None:
            self.set_start(state)
    
    def set_start(self, start):
        """Sets the given state as the start state for the search and
        initializes the search tree and parameters."""
        
        # Reset the list of visited states
        self.clear_visited()
        
        self.fringe = _FibonacciHeap()
        # We don't have a goal node yet
        self.goal = None
        self.bestAvailableGoalCost = float('inf')
        # Start with node id 0
        self.nid = 0

        if self.boundGoalCost and self.testGoalOnGeneration:
            raise ValueError("Invalid settings, can't use the goal cost bound as well as testGoalOnGeneration")
        
        # Set up a search-tree node for the start state
        self.root = self.add_successor(None, start, None, 0)

        if self.testGoalOnGeneration and self.is_goal(start):
            self.goal = self.root
            return
        
    def search(self):
        """Run a search to completion or failure.  Return True if a solution
        is found, or False on failure."""
        
        while not self.fringe.is_empty():
            res = self.search_step()
            if res:
                return True
        return False
    
    def search_step(self):
        """Perform one step of an A* search.

        A step is defined as removing one node from
        the fringe, generating its successors, testing the node or its
        successors for goal conditions (depending on the value of
        testGoalOnGeneration when the AStar object was created), and appending
        the successors to the priority-queue search fringe.

        Returns:
            (bool): True if a goal state is found during this step, False
            otherwise. 
        """
        
        if self.fringe.is_empty():
            return False
        
        # Get the fringe node with the minimal key and extract our search state
        n = self.fringe.extract_minimum()[1]
        del n.heapNode
        
        # Check goal condition
        if (not self.testGoalOnGeneration) and self.is_goal(n.state):
            self.goal = n
            return True
        
        # Generate successors
        if self.boundGoalCost:
            res = self.successors(n.state,maxCost = self.bestAvailableGoalCost-n.g)
        else:
            res = self.successors(n.state)
        successors = res[0]
        costs = res[1] if len(res) > 1 else [1]*len(successors)
        edges = res[2] if len(res) > 2 else [None]*len(successors)
        assert len(successors) == len(costs)
        assert len(successors) == len(edges)
        for c in costs:
            assert isinstance(c,(int,float)),"Invalid cost, got an instance of type "+c.__class__.__name__
        
        # Do some tests on the successors
        for succ, cost, edge in zip(successors, costs, edges):
            # Goal test if appropriate
            if self.testGoalOnGeneration and self.is_goal(succ):
                self.goal = self.add_successor(n,succ,edge,cost)
                return True
            if self.boundGoalCost:
                if n.g+cost >= self.bestAvailableGoalCost:
                    #skip any nodes that might be worse than an available goal
                    continue
                if self.is_goal(succ):
                    self.bestAvailableGoalCost= min(self.bestAvailableGoalCost,n.g+cost)
            
            # Check to see if the state has been visited before in the search
            visited = self.visited_state_node(succ)
            # State was visited before, check its cost
            if visited:
                # This is a longer path from the start to this state than
                # before, so ignore this successor
                if n.g + cost >= visited.g:
                    continue
                # This is a shorter path to this state than before, so
                # adjust its value in the fringe
                else:
                    # First, remove the prior instance from the fringe
                    if hasattr(visited,'heapNode'):
                        try:
                            self.fringe.delete(visited.heapNode)
                        except (Exception) as e:
                            print("Deleting from fringe failed.  "\
                                  "Heuristic inadmissible or inconsistent?")
                            raise
                                #print e
                                #traceback.print_exc()
                        del visited.heapNode
                    # Second, add the new version of the state
                    self.add_successor(n,succ,edge,cost)
            # This state hasn't been visited before, so just add it
            else:
                self.add_successor(n,succ,edge,cost)
                
        return False
        
    def add_successor(self, parent, state, parentedge, cost):
        """An internal operation.  The user should NOT call this method.
        Adds a new node to the search tree with the given parent, and
        returns the successor.
        """
        
        # Set up a new node as a child of the parent
        g = parent.g + cost if parent else 0
        h = self.heuristic(state)
        f = h+g
        child = AStarNode(f,h,g,self.nid,state,parent,parentedge)
        self.nid += 1
        if parent:
            parent.children.append(child)
        # Put it in the fringe
        # Tuples are sorted lexicographically, so nodes are sorted by
        #  f-score first, then h-score, then g-score.
        child.heapNode = self.fringe.insert( (f,h,g), child )
        # Mark this state visited and map it to the new search node
        self.visit(state, child)
        
        return child
        
    def num_nodes(self):
        """Returns the number of nodes in the search tree."""
        return 1 + self.num_descendents(self.root)
        
    def num_descendents(self, node):
        """Returns the number of descendents of the given search-tree node."""
        count = len(node.children)
        for child in node.children:
            count += self.num_descendents(child)
        return count

    def path_to(self,n):
        """Returns a list of AStarNode's up to the AStarNode n.
        """
        path = []
        while n != None:
            path.append(n)
            n = n.parent
        path.reverse()
        return path

    def result_path(self):
        """Returns a list of AStarNode's up to the goal, if a goal has been
        found.  Otherwise, an empty list is returned.
        """
        return self.path_to(self.goal)

    def result_cost(self):
        return self.goal.g

    def result_path_states(self):
        """Returns a list of states up to the goal"""
        return [n.state for n in self.result_path()]

    def result_path_edges(self):
        """Returns a list of edges up to the goal"""
        return [n.parentedge for n in self.result_path()]
        
        
        
    ##################################
    # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #
    # The following should be overloaded by a subclass!
    #
    
    def is_goal(self, state):
        """Returns True if the given state is a goal, otherwise False.  

        Abstract in this definition; should be overloaded by a subclass.

        Internal; users may call this method but have little reason to.
        """
        pass
        
    def successors(self, state, maxCost=float('inf')):
        """
        Args:
            state: the user-defined state
            maxCost (float, optional): if given, there is no need to return
                successors whose cost exceeds this value.  Respecting this
                value is optional, but using it may help to prune some
                successors that cannot be optimal.

        Returns:
            (tuple): the result may contain one, two, or three lists:
            - A list of all legal successor states to the given state.
            - A list of corresponding costs to move to those states.
            - A list of data to be attached to each edge (e.g., an action
              identifier)
        
        Abstract in this definition; should be overloaded by a subclass.

        Internal; users may call this method but have little reason to.
        """
        pass
        
    def clear_visited(self):
        """Clears the list of visited states and their mappings to AStarNode
        instances.  See visit() and visited_state_node(). 

        Abstract in this definition; should be overloaded by a subclass.

        Internal; users should NEVER call this method.
        """
        pass
        
    def visit(self, state, node):
        """Marks the given state as visited and maps it to a given AStarNode.
        See visited_state_node() and clear_visited().  

        Abstract in this definition; should be overloaded by a subclass.

        Internal; users should NEVER call this method.
        """
        pass
        
    def visited_state_node(self, state):
        """If the given state has been visited, returns the associated
        AStarNode.  Otherwise, returns None.  See visit() and clear_visited().
        
        Abstract in this definition; should be overloaded by a subclass.

        Internal; users may call this method but have little reason to.
        """
        pass
        
    def heuristic(self, state):
        """Returns a heuristic value for the given state.  This heuristic
        should ideally fulfill the requirements for admissibility and
        consistency.  

        Abstract in this definition; should be overloaded by a subclass.

        Internal; users may call this method but have little reason to.
        """
        return 0

    def tree_size(self,root=None):
        """Returns the number of nodes in the search tree or subtree"""
        if root==None:
            if self.root == None: return 0
            return self.tree_size(self.root)
        return 1+sum(self.tree_size(c) for c in root.children)

    def best_node(self,quantity='f'):
        """Upon a failed plan, returns the best node for the given
        quantity, which can be either f, g, or h."""
        q = [self.root]
        best = self.root
        bestval = self.root.f if quantity == 'f' else -self.root.g if quantity == 'g' else self.root.h
        while len(q) > 0:
            n = q.pop()
            cmpval = n.f if quantity == 'f' else -n.g if quantity == 'g' else n.h
            if cmpval < bestval:
                best = n
                bestval = cmpval
            for c in n.children:
                q.append(c)
        return best


class AStarHashable(AStar):
    """An AStar instance where each state is hashable (e.g., a tuple) using the
    standard Python hash. Visited state detection is handled using a dict.

    This is a helper class that makes it easier to implement A* search. Using
    this as your base class rather than AStar, you only need implement the
    is_goal(), successors(), and heuristic() methods.
    """
    def __init__(self,state=None,testGoalOnGeneration=False):
        AStar.__init__(self,state,testGoalOnGeneration)
        self.visited = dict()

    def clear_visited(self):
        self.visited = dict()

    def visit(self, state, node):
        self.visited[state] = node

    def visited_state_node(self, state):
        return self.visited.get(state,None)



########################
# fibheap.py
#
# An implementation of a Fibonacci heap.
# Fibonacci heaps do decrease-key operations
# in amortized constant time, making them
# more suitable for A* search than Python's
# heapq module, which requires a linear-time
# re-heap operation for every decrease-key or
# arbitrary deletion.
#
# Written: Mark Wilson (mw54) 9/1/2010
# Last updated: 9/6/2010
########################

"""This is the fibheap module.  It defines classes for a Fibonacci heap and
nodes in the heap.  A Fibonacci heap is a min-heap with special running-time
constraints that make it more suitable for certain applications than Python's
built-in heapq module."""

# A node in the Fibonacci heap.
class _FibonacciNode:
	"""Represents a node in a FibonacciHeap.  The key and data values that are
	stored in the node are available as "node.key" and "node.data" respectively.
	Users generally should not need other members of this type.
	
	Usually you will not need to create a FibonacciNode directly (see 
	FibonacciHeap.insert()).  Nor should you manipulate its members directly --
	see FibonacciHeap for member functions that manipulate node values."""
	
	def __init__(self, key, data=None, parent=None):
		"""Sets up a new, unmarked node with the given key, data value, parent
		node, and an empty list of children.
		
		Values of interest to the user are probably key and data values, which
		are stored internally at "node.key" and "node.data" respectively."""
		
		self.key = key
		self.data = data
		# Since parent holds a ref to children, we want a weak reference
		# to the parent to ensure garbage collection despite circular refs
		self.parent = weakref.ref(parent) if parent else parent
		self.children = []
		self.marked = False
		
# A Fibonacci heap.
class _FibonacciHeap:
	"""A Fibonacci heap is a special data structure that functions as a
	min-heap but, unlike the standard binomial heap, can do decrease-key or
	delete operations on arbitrary heap nodes in amortized constant and log-n
	time, respectively.  This makes it particularly well-suited for
	applications like an A* search where arbitrary values in the heap may
	need to be revised online."""
	
	def __init__(self):
		"""Creates a new, empty Fibonacci heap."""
		
		# roots is a set for fast lookups and set operations -- contains
		# the root nodes for all trees in the heap.
		self.roots = set()
		# reference to the current minimal node
		self.minimum = None
		
	def is_empty(self):
		"""Returns True if the heap is empty, otherwise False."""
		
		return len(self.roots) == 0
	
	def clear(self):
		"""Empties the heap."""
		
		self.roots = set()
		self.minimum = None
		
	# Internal operation -- won't HURT for users to call this (it should
	# be a no-op from the user's perspective), but doesn't help and wastes time.
	#
	# Finds the minimum-valued node in the current root set.
	def find_minimum(self):
		"""This is an internal function that the user should never have to call.
		From the user's perspective it should be a somewhat expensive no-op."""
		
		if len(self.roots) == 0:
			self.minimum = None
			return
		for n in self.roots:
			if self.minimum == None or n.key < self.minimum.key:
				self.minimum = n
	
	# Merges this heap with another heap.
	def merge(self, other):
		"""Merges this heap with FibonacciHeap "other".  After the merge,
		the nodes from both heaps will be contained in this heap."""
		
		# Add the other heap's roots
		self.roots &= other.roots
		# The minimal node is one of our minimum or the other's minimum.
		if len(self.roots) == 0:
			self.minimum = None
			return
		if self.minimum == None:
			self.minimum = other.minimum
			return
		if other.minimum == None:
			return
		if other.minimum.key < self.minimum.key:
			self.minimum = other.minimum
		
	# Inserts a new node into the heap with the given key and data.  Returns
	# the new FibonacciNode created.
	def insert(self, key, data):
		"""Inserts a new node into the heap with the given key and data value.
		Returns the FibonacciNode holding the given values. Operates in
		amortized constant time."""
		
		# Just make a node and add it to the roots.
		n = _FibonacciNode(key,data)
		self.roots.add(n)
		# Update minimum if appropriate
		if self.minimum == None or n.key < self.minimum.key:
			self.minimum = n
		return n
		
	# Returns the minimal node (key, data) but does not remove it.
	def peek_minimum(self):
		"""Returns the (key, data) pair of the minimally-valued FibonacciNode
		in the heap, but does not remove the min-node."""
		
		return (self.minimum.key, self.minimum.data)
		
	# Removes and returns the minimal node (key, data) in the heap.
	def extract_minimum(self):
		"""Returns the (key, data) pair of the minimally-valued FibonacciNode
		in the heap, and removes that node from the heap.  Operates in
		amortized O(log n) time."""
		
		# Grab the minimal node
		if self.minimum == None: return None
		m = self.minimum
		# Remove the minimal node, reset the reference to it, and
		# reparent its children to be root nodes.
		try:
			self.roots.remove(m)
		except:
			print('minimum is',m.key,',',m.data)
			for r in self.roots:
				print('root',r.key,',',r.data)
			raise
		self.minimum = None
		for c in m.children:
			c.parent = None
			c.marked = False
			self.roots.add(c)
		m.children = []
		
		# Iterate over the root list, checking for nodes with the same degree.
		# When nodes with the same degree are found, make the one with the
		# larger key a child of the other.
		# Repeat until no roots with the same degree exist.
		collision = True
		while collision:
			# Map from degree values to root nodes
			degreeDict = {}
			# not safe to remove from an iterable while we iterate over it.
			# Thus keep a set of nodes to be removed and take them all out
			# at the end.
			removedRoots = set()
			for n in self.roots:
				deg = len(n.children)
				if deg in degreeDict:
					if degreeDict[deg].key < n.key:
						smaller = degreeDict[deg]
						larger = n
					else:
						smaller = n
						larger = degreeDict[deg]
					smaller.children.append(larger)
					larger.parent = weakref.ref(smaller)
					degreeDict[deg] = smaller
					removedRoots.add(larger)
				else:
					degreeDict[deg] = n
			collision = (len(removedRoots) != 0)
			self.roots -= removedRoots
		
		# Find the new minimum node
		self.find_minimum()
		# Return the old minimum node
		return (m.key, m.data)
		
	# An internal operation -- should never be called by the user!
	#
	# Removes given node from its parent, makes it a root node, and returns
	# the parent node.
	def cut_node(self, node):
		"""This is an internal function.  Users should NEVER call this function,
		as it will probably violate all kinds of heap properties."""
		
		if node.parent == None:
			raise RuntimeError("Node to be cut is already root")
		p = node.parent()
		p.children.remove(node)
		node.parent = None
		node.marked = False
		self.roots.add(node)
		if node.key < self.minimum.key:
			self.minimum = node
		return p
		
	def decrease_key(self, node, key):
		"""Decreases the key on the given node to the new value.  Operates in
		amortized constant time."""
		
		if key >= node.key:
			raise RuntimeError("New key must be less than old key: %f >= %f" \
								% (key, node.key))
		
		node.key = key
		if node.parent == None:
			if node.key < self.minimum.key:
				self.minimum = node
			return
		if node.key >= node.parent().key:
			return
		
		n = self.cut_node(node)
		while n.marked:
			n = self.cut_node(n)
		
		if n.parent != None:
			n.marked = True
			
	def delete(self, node):
		"""Deletes the given node from the tree.  Operates in amortized O(log n)
		time."""
		self.decrease_key(node, -sys.float_info.max)
		self.extract_minimum()
